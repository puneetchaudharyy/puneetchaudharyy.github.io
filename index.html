<!DOCTYPE html>
<html>
  <body>
    <h1>Hello World</h1>
    <p>I'm hosted with GitHub Pages.</p>
    <h2> NAME: Puneet Chaudhary <br>
        Std.ID 1231356 <br>
        GitHub repository: https://github.com/puneetchaudharyy/puneetchaudharyy.github.io <br>
        GitHub Pages: https://puneetchaudharyy.github.io/ <br>
    </h2>
    <p> Software development process is the foundation of any software development project. It helps simplify the building process by dividing the work into smaller, parallel or sequential steps or sub-processes to simplify the work. This process is also called software development life cycle (SDLC). One of the more popular models used for software development is the Waterfall Method. This method divides the development process into analysis, design, implementation, testing, launch and maintenance. Although a popular approach, the waterfall method has some shortcomings. One of them is that it is very hard to get feedback on the project during the development. This is bad because the software being developed is for the larger public. This makes it harder to make changes in the program. Another approach is the spiral method which was introduced in 1988. The spiral method is a development cycle that combines the iterative development process model with elements of the waterfall method. This method has proven to work better than the previous Waterfall method.</p>
    <p></p>Software design is crucial in businesses and architecture. Building a software without a plan is like building a house without setting a foundation, it is bound to collapse. Software design helps with that. The main objectives of a software design model are to achieve correctness, efficiency, understandability, completeness and maintainability. Apart from this, software design ensures the traceability of the software which makes improving and making changes to the software when there is a bug easier. </p> 
    <p></p>PostgreSQL is one of the best engineered DBMS I have ever used. It makes database management really convenient and efficient. The interface is next to none and the concurrency and performance features are very helpful in parallelization of read queries and building B-tree indexes. It’s extensibility to languages like Python, Java and Rust was really helpful to me when I made JavaScript projects of my own. </p>
    <p>
      1.Requirements gathering is very important in the software development process. It ensures that the software is being built on the preferences and requirements of the user. This is vital because the software is going to be used by them. It also lays down a solid foundation and makes the objective of the program clearer. This step helps to ensure that the final product meets the needs of the stakeholders and end users, and that it is developed within the constraints of the project, such as budget and schedule.
      The requirements gathering stage starts with the team of developers sitting and discussing the main purpose of the software. They lay down the most basic requirements first and then proceed to decide on the more specific features or services that the user would benefit from.
      One of my favourite ways to do requirements gathering is through process maps and flowcharts. It gives a simplified depiction of the functionality we want to deploy. For e.g., If one wants to map their business processes, user flows and sometimes even for explaining their requirement gathering process to other members of the team or the stakeholders and even users.
      
      2.	User stories for PostgreSQL:
          a.	As a database manager, I should be able to see all the columns and their properties, so that I can make changes in the variable type, length of the entered value, etc.
          b.	As a teacher, I should be able to display the marks of students in chronological order according to different columns, so that I can identify which students are lacking and need more attention.
          c.	As a sales manager, I should be able to export and import data from other applications in potentially different formats, so that I can make changes as and when required.
          d.	As a user, I shall be able to protect my databases with a password, so that only authorised people can access it.
          e.	As a user, I want to know all the previous queries, so that I can go back to see the results and save time and also to identify any errors that I did while previously writing the query.
    </p>
    <p>
      Empathy in contrast to sympathy is understanding a person or a group of people’s subjective experience. This avoids the distance of pity as with sympathy. Empathy leads to deeper connections between people. Empathy is more than just a gut feeling because id so was the case we wouldn’t need surveys, focus groups, interviews, or ethnographies. The reason we do research is to objectively observe behaviours and explanations while balancing it with empathetic understanding. Empathy isn’t a tool limited to the world of design. It is a powerful tool for every professional. Cultivating empathy is vital for an organisation to have a realistic view of people’s lives. The top three models discussed in the chapter which lack empathy are Consumers, Home Economicus, and the Human factors. Consumers is probably the worst out of all as it narrows down people to just beings that consume products and services. The model is completely devoid of empathy and tells nothing about the characteristics or preferences of the user. The homo economicus model views human behaviour as a calculation to maximise utility. This model focuses on what prompts the user rather than on the user and their experience. These businesses focus on quantity rather than quality. The last model, called the “Human Factor” model did consider how the users used the products and services. While this was an improvement from the previous models, it still lacked some serious components of empathy. The view assumes everyone to be a robot who always has specific preferences. This classic “tasks and goals” viewpoint is too shallow to address all aspects of customer service. This is clear from the wide range of feature-rich but of no use products on the market.
    </p>
    <p>
      At PostgreSQL, the goal is to make a fundamental change in the way we think about designing and delivering products and services. It argues for a user-centric, holistic, and adaptable approach that considers the entire customer experience and encourages businesses to stay responsive to changing market dynamics.
      Designing for change is a central theme, as markets and user needs evolve. This approach involves constantly gathering feedback and data to refine and adapt products and services.
      Addressing the necessity of evolving business models to accommodate these shifts in product design. This involves exploring subscription-based models, product-service hybrids, or other innovative strategies. With the paid version of PostgreSQL, one can scale PostgreSQL for time series, events, and analytics with Timescale’s automatic time-based partitioning and indexing, incrementally updated materialized views, columnar compression, and time series hyperfunctions.
      Get 10-100x faster time series queries than vanilla PostgreSQL, InfluxDB, and MongoDB with automatic time-based partitioning and indexing. Give your users answers in milliseconds, not minutes with Timescale’s continuous aggregates. Instead of just focusing on the physical features of a product, Postgre considers the entire user experience, from discovery and purchase to post-purchase support and use.
      This persona is of Hiroshi Tanaka who has been using PostgreSQL for the past 4 years and he shares his motivations and experiences in life. He is happy with the product and speaks greatly of it.<br>
      <img src = "https://photos.google.com/u/2/photo/AF1QipPX5-5V-dnld19aS9p-flarxi9wigZqr-Hpb1Fj">
    </p>
    <p>
      Prototyping is the fundamental concept in software development which involves creating a preliminary or a partial version of a software product to better understand and feel the working of a software development. It doesn’t necessarily show all the functionalities but touches on some typical features.
The practice of prototyping helps visualise the product which is more comprehensive than documentation or diagrams. Prototyping also helps for the validation of initial requirements. It confirms the feasibility of the software and checks whether the requirements align with the user’s expectations. Addressing issues and changes early into the software development process will help in reducing costs and time to make changes in the product when it becomes more complex and integrated.
Benefits of using prototypes:<br>
1.	Idea exploration: Prototyping helps users like developers, designers and clients to clarify their ideas. It allows for a solid representation of software early into the development cycle. <br>
2.	User feedback: Prototypes can be used to gather feedback and end-users and stakeholders. This feedback is valuable for making decisions about the product’s features. <br>
3.	Risk mitigation:  Early prototypes can help identify potential technical challenges or design flaws before significant resources are invested in development. This helps in risk assessment and mitigation. <br>
Paper prototyping <br>
1.	Choose the most important user: Choose a typical user of the software and look at the product from his perspective. <br>
2.	Determine some typical tasks: Determining the main tasks that the software performs and categorize them. <br>
3.	Make screen shots or sketches: Visualise the interface of the product and draw it on a paper. This visualisation helps identifying design flaws and saves resources. <br>
4.	Perform a usability test: This requires interacting with the user. Make a basic working prototype of the software and gather the user’s opinions on the functionalities and interface of the product.
    </p>
    <p>
      Communication in software design has paramount importance. Good communication enables all stakeholders, including, designers, project managers, clients and end-users, to be on the same wavelength throughout the software development process. 
Effective communication is crucial for several reasons: <br>
1.	Understanding requirements: Having a clear conversation with the stakeholders is essential to understand the requirements of the software. Without such a conversation, it is difficult to design a software that appeals to the people and fulfils their requirements. <br>
2.	Collaboration: Software design aims at combining the unique skills of every member of the team, such as designers, project managers and developers. Having in-depth conversations about the goal of the project ensures that everyone works with the same goal in mind, i.e., to make the software user friendly and have the scope of advancement in the future. <br>
3.	Risk management:  By communicating effectively with everyone involved in the project is pivotal for software design. Being able to openly communicate about the potential shortcomings of the project will help in developing strategies to mitigate the risks thus reducing the chances of project failure. <br>
One day, me and my friend decided to meet for dinner. We both agreed to meet at a restaurant at 8:00 PM. I thought I had made it clear where we had to meet, but my friend thought of a different branch of the restaurant. When I arrived at the place, I called up my friend just to realise that he had gone to a different branch. This led to me driving to other part of the city to meet him for dinner which delayed aur plans substantially.<br>
How I could have handled it better: <br>
1.	I could have sent him a detailed message about when and where we had to meet for the dinner. This small step could have avoided a lot of confusion. <br>
2.	I should have travelled earlier to the spot to make-up for any delays and cause much inconvenience.<br>
3.	I ended up arguing with the friend on the matter. I shouldn’t have done that and rather worked together to find the solution and adapt to the situation at hand. Instead, we decided to argue which further delayed our plan. <br>
This everyday scenario illustrates that effective communication, even in seemingly simple plans, can prevent misunderstandings and make social interactions smoother.
    </p>
    <p>
      The Pareto Principle, named after the Italian economist Vilfredo Pareto, states that 80% of the outcomes or consequences result from 20% of causes or inputs. Originally, the principle was derived after observing the relationship between the wealth and population of Italy in the late 1980s.<br>
Over the years, the principle was applied to many industries and topics, including time management strategies. One example is, 80% of the website traffic stems from 20% of the website content. As a time management strategy, we might find that 20% of the efforts and tasks account for 80% of the results. So, we might want to bump up these tasks.<br>
Similarly, the principle can be applied to software design. There are multiple cases where we can relate this concept to the world of software. Two of these examples could be:<br>
I.	Prototyping <br>
Prototyping is critical to software design and the 80/20 rule can apply to the prototyping process. With a prototyping process, developers can pull together 20% of a product and obtain feedback from the shareholders. They can use this to determine if they should proceed with the product or not. <br>
Prototyping is a great example of the 80/20 rule because we can develop way less product but get majority of the feedback needed in a matter of a few days instead of months.<br>
II.	Writing Assignments <br>
When deciding to do the writing assignment, instead of spending 1 hr drafting it when one isn’t sure what to do or what is needed, one can spend 10 minutes thinking of ideas and making rough bullet pints of what to write in the assignment. Then spend the 50 minutes writing the actual assignment. <br>
    </p>
  </body>
</html>
